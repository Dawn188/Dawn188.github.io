<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>员工管理系统做题方法</title>
      <link href="/2022/12/29/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%81%9A%E9%A2%98%E6%96%B9%E6%B3%95/"/>
      <url>/2022/12/29/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%81%9A%E9%A2%98%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="员工管理系统解密"><a href="#员工管理系统解密" class="headerlink" title="员工管理系统解密"></a>员工管理系统解密</h1><h2 id="首先创建实体类"><a href="#首先创建实体类" class="headerlink" title="首先创建实体类"></a>首先创建实体类</h2><ul><li><p>声明数据库表中所有的字段，并设置注解@Data，是为了提高代码的简洁，可以直接省去实体类中大量的get()set()toString()等方法，直接写入注解@Getter，@Setter即可。</p></li><li><p>注意要求：</p><p>要求设置字段不能为空，可以添加注解：@NotNull(message  &#x3D; “字段不能为空”)，表示不能为null，但是可以为empty；或者</p><p>@NotBlank(message &#x3D; “字段不能为空”)，表示只能作用在String上，而且调用trim()后，长度必须大于0.</p><p>要求合理性：</p><p>薪资合理，所以不能为负，设置@Min(0)。</p><p>手机号和身份证号合理，</p><p>@Pattern(regexp &#x3D; “   “, message &#x3D; “字段格式有误”)；</p><p>如：@Pattern(regexp &#x3D; “^[1][3,4,5,6,7,8,9][0-9]{9}$”, message &#x3D; “手机号格式有误”)，表示第一个数字为1，第二个数字是[3-9]任意数字，其余9位是[0-9]任意数字。</p><p>如：@Pattern(regexp &#x3D; “^(\d{18,18} | \d{15,15} | (\d{17,17} [x|X]))$”, message &#x3D; “身份证号格式有误”)，表示身份证号可以是18位，15位，或者17位+X。</p><p>要求时间格式：</p><p>如：@JsonFormat(pattern &#x3D; “yyyy-MM-dd”,timezone &#x3D; “GMT-8 “)，表示时间格式位年月日。它是来源于jackson，可以很好的解决后台到前台时间格式保持一致的问题</p><p>@DataTimeFormat(pattern  &#x3D; “yyyy-MM-dd”)。它是来源于spring自带的处理框架，可以很好的解决前台传递给后台的时间格式不一致的问题。</p></li></ul><h2 id="创建model包，vo-后端–-gt-前端-，dto-前端–-gt-后端"><a href="#创建model包，vo-后端–-gt-前端-，dto-前端–-gt-后端" class="headerlink" title="创建model包，vo(后端–&gt;前端)，dto(前端–&gt;后端)"></a>创建model包，vo(后端–&gt;前端)，dto(前端–&gt;后端)</h2><ul><li>同样将实体类中所声明的字段全部写进vo中，添加@Data注解。</li><li>由于添加和修改操作需要从前端传入，所以要在前端中写入AddDTO和UpdDTO.</li></ul><h4 id="创建common包添加一些共享类"><a href="#创建common包添加一些共享类" class="headerlink" title="创建common包添加一些共享类"></a>创建common包添加一些共享类</h4><ul><li><p>创建一个返回类R，public class R<T> implements Serializable。</p><p>将它写成泛型，这样，都能与之匹配。完后加上必要的msg、status以及返回的核心数据data，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String status;<span class="comment">//用于表示网络和报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String code;<span class="comment">//用于表示代码情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T data;</span><br></pre></td></tr></table></figure></li><li><p>然后在其写入返回的ok和fail语句，用于之后使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(<span class="literal">null</span>, CommonConstants.SUCCESS, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(data, CommonConstants.SUCCESS, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data, String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(data, CommonConstants.SUCCESS, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">failed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(<span class="literal">null</span>, CommonConstants.FAIL, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">failed</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(<span class="literal">null</span>, CommonConstants.FAIL, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">failed</span><span class="params">(T data)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(data, CommonConstants.FAIL, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">failed</span><span class="params">(T data, String msg)</span>    &#123;</span><br><span class="line">    <span class="keyword">return</span> restResult(data, CommonConstants.FAIL, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">restResult</span><span class="params">(T data, <span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">    R&lt;T&gt; apiResult = <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;();</span><br><span class="line">    apiResult.setCode(code);</span><br><span class="line">    apiResult.setData(data);</span><br><span class="line">    apiResult.setMsg(msg);</span><br><span class="line">    <span class="keyword">return</span> apiResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加Page类，用于分页查询时使用，设置一些默认初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每页显示条数，默认 10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; records = Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建CommonConstants类，添加进一些常用的常量，这里是成功标志和失败标志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommonConstants</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">SUCCESS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">FAIL</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分页查询功能"><a href="#分页查询功能" class="headerlink" title="分页查询功能"></a>分页查询功能</h3><h4 id="开始编写controller类"><a href="#开始编写controller类" class="headerlink" title="开始编写controller类"></a>开始编写controller类</h4><ul><li><p>首先添加注解@RestController，它是@ResponseBody+@Controller的结合。使用这个注解不能返回jsp，html页面。</p></li><li><p>其次添加注解@RequestMapping(value &#x3D; “”)，用于处理请求地址映射。</p></li><li><p>添加注解@AllArgsConstructor，它是lombok中的注解，作用于类上，使用后添加一个构造函数，该函数含有实体类中声明的字段属性参数。一般使用final来声明变量，让其不能被继承。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EmpInfoService empInfoService;</span><br></pre></td></tr></table></figure></li><li><p>查询使用get，所以将分页查询添加地址映射注解为@GetMapping(“”)。</p></li><li><p>分页查询需要两个参数，当前页curPage和每页显示页数pageSize。</p><p>创建Page对象，设置两个参数的值，并将curPage和pageSize的值传入对象中，返回service方法。</p></li></ul><h4 id="进入service接口层中"><a href="#进入service接口层中" class="headerlink" title="进入service接口层中"></a>进入service接口层中</h4><ul><li><p>首先添加注解@Service，标记当前类是一个service类，加上注解后会将当前类自动注入到spring容器中，就不需要要在xml中定义bean。</p></li><li><p>接口层需要继承IService&lt;&gt;，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpInfoService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;EmpInfo&gt; </span><br></pre></td></tr></table></figure></li><li><p>使用Mybatis-plus的分页插件—IPage，将Page对象传入。</p></li><li><p>返回值类型是vo</p></li></ul><h4 id="进入serviceImpl实现类"><a href="#进入serviceImpl实现类" class="headerlink" title="进入serviceImpl实现类"></a>进入serviceImpl实现类</h4><ul><li>添加注解@Service和@AllArgsConstructor，声明mapper变量。</li><li>添加注解@Overrride，用于在重写父类的时候，程序可以进行判断写的是否正确，而且加上它，程序会自动屏蔽父类的方法</li><li>返回mapper接口层的方法，传入对象Page和useFlag的参数。</li></ul><h4 id="进入mapper"><a href="#进入mapper" class="headerlink" title="进入mapper"></a>进入mapper</h4><ul><li>首先添加注解@Mapper，起到描述性作用。</li><li>继承BaseMapper&lt;&gt;。</li><li>写入分页查询的方法。</li></ul><h4 id="进入xml中"><a href="#进入xml中" class="headerlink" title="进入xml中"></a>进入xml中</h4><ul><li><p>开头指定为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>&#96;&#96;&#96;java</p><mapper namespace="Mapper类的地址">    //sql语句</mapper><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 写入sql语句，分页查询可以说是查询全部，但是要注意要求use_flag有效。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  &lt;select id=&quot;getAllEmpInfolimit&quot; resultType=&quot;//结果类型返回值或者返回体位置&quot;&gt;</span><br><span class="line">  </span><br><span class="line">      //分页查询sql语句</span><br><span class="line">  </span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="根据id查询功能"><a href="#根据id查询功能" class="headerlink" title="根据id查询功能"></a>根据id查询功能</h3><h4 id="controller类"><a href="#controller类" class="headerlink" title="controller类"></a>controller类</h4><ul><li>查询使用get，所以地址映射注解为@GetMapping(“&#x2F;{id}”，表示根据id进行查询。</li><li>写入带有参数的构造方法，在参数前面带上注解@PathVariable，表示映射URL绑定的占位符，将URL中占位符参数绑定到控制器处理方法的入参中。</li><li>返回service方法。</li></ul><h4 id="Service接口类"><a href="#Service接口类" class="headerlink" title="Service接口类"></a>Service接口类</h4><ul><li>返回值类型是vo</li></ul><h4 id="serviceImpl实现类"><a href="#serviceImpl实现类" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>方法相同</li></ul><h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><ul><li>方法相同</li></ul><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><ul><li><p>由于返回值是vo，所以在resultType结果类型中写入vo的地址</p></li><li><p>再填入sql语句，注意的是use_flag要有效。</p></li><li><p>由于是必传参数id，所以需要判断id是空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;where&gt;</span><br><span class="line">    use_flag  = <span class="number">1</span></span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;id != null and id !=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">        <span class="type">and</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="增添功能"><a href="#增添功能" class="headerlink" title="增添功能"></a>增添功能</h3><h4 id="controller类-1"><a href="#controller类-1" class="headerlink" title="controller类"></a>controller类</h4><ul><li><p>增加是post功能，所以要用注解@PostMapping(“ “)</p></li><li><p>由于增加功能是从前端传给后端，所以需要创建一个类AddDTO，将它作为参数传入这个方法中，并添加注解@RequestBody,用于接收前端传给后端的数据。</p></li><li><p>最后返回service的方法。</p></li></ul><h4 id="service接口类"><a href="#service接口类" class="headerlink" title="service接口类"></a>service接口类</h4><ul><li>返回值类型是boolean型</li></ul><h4 id="serviceImpl实现类-1"><a href="#serviceImpl实现类-1" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>根据要求，工号和手机号要唯一，所以在新增员工的时候要注意，不能增加相同的工号和手机号。</li><li>调用mapper里的方法，判断工号、手机号是否为0，来将增添的东西插入。</li><li>返回true。</li></ul><h4 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h4><ul><li>给出工号和手机号的方法体，注意参数类型和实体类对应。</li></ul><h4 id="xml-1"><a href="#xml-1" class="headerlink" title="xml"></a>xml</h4><ul><li><p>新增信息用insert，加入参数类型parameterType，填入AddDTO的地址。</p></li><li><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insertEmpInfo&quot;</span> parameterType=<span class="string">&quot;com.example.test001.model.dto.EmpInfoAddDTO&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    insert into emp_manage.emp_info(no,name,phone,idcard,org_id,crt_time,salary,position,use_flag)</span><br><span class="line">     values(#&#123;no&#125;,#&#123;name&#125;,#&#123;phone&#125;,#&#123;idcard&#125;,#&#123;orgId&#125;,#&#123;crtTime&#125;,#&#123;salary&#125;,#&#123;position&#125;,#&#123;useFlag&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></li><li><p>唯一性的判断的sql语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getIsNoExist&quot;</span> resultType=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span><br><span class="line">    select <span class="title function_">count</span><span class="params">(*)</span> from emp_manage.emp_info <span class="type">where</span> <span class="variable">no</span> <span class="operator">=</span> #&#123;no&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;getIsPhoneExist&quot;</span> resultType=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span><br><span class="line">    select <span class="title function_">count</span><span class="params">(*)</span> from emp_manage.emp_info <span class="type">where</span> <span class="variable">phone</span> <span class="operator">=</span> #&#123;phone&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><h4 id="controller类-2"><a href="#controller类-2" class="headerlink" title="controller类"></a>controller类</h4><ul><li>调用接口为delete，并且是根据id来进行删除，所以注解为@DeleteMapping(“&#x2F;delete&#x2F;{id}”)。</li><li>返回service方法。</li></ul><h4 id="service接口类-1"><a href="#service接口类-1" class="headerlink" title="service接口类"></a>service接口类</h4><ul><li>返回类型是boolean型。</li></ul><h4 id="serviceImpl实现类-2"><a href="#serviceImpl实现类-2" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>实现构造方法，传入mapper的方法。</li><li>返回true。</li></ul><h4 id="mapper类-1"><a href="#mapper类-1" class="headerlink" title="mapper类"></a>mapper类</h4><ul><li>方法类型是boolean</li></ul><h4 id="xml-2"><a href="#xml-2" class="headerlink" title="xml"></a>xml</h4><ul><li><p>由于删除操作没有resultType和parameterType，所以不需要添加，将mapper的返回对象作为id就好。</p></li><li><p>根据要求，删除操作是将use_flag判断为无效，并不是将整条数据删除，所以sql用update set进行写入。</p></li><li><p>由于要根据id进行删除操作，所以要判断id是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=<span class="string">&quot;deleteEmpInfo&quot;</span> &gt;</span><br><span class="line">    update emp_manage.emp_info</span><br><span class="line">    <span class="type">set</span> <span class="variable">use_flag</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;id != null and id != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h3><h4 id="controller类-3"><a href="#controller类-3" class="headerlink" title="controller类"></a>controller类</h4><ul><li>修改调用接口put，添加注解为@PutMapping(“&#x2F;update”)。</li><li>由于要从前端传入操作，所以需要将UpdDTO传入，并添加注解@RequestBody。</li><li>返回service的方法。</li></ul><h4 id="service接口类-2"><a href="#service接口类-2" class="headerlink" title="service接口类"></a>service接口类</h4><ul><li>方法类型boolean</li></ul><h4 id="serviceImpl实现类-3"><a href="#serviceImpl实现类-3" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>修改信息也会涉及到工号和手机号的唯一性，所以需要进行判断，再将mapper方法传入</li><li>返回true。</li></ul><h4 id="mapper类-2"><a href="#mapper类-2" class="headerlink" title="mapper类"></a>mapper类</h4><ul><li>方法类型boolean。</li></ul><h4 id="xml-3"><a href="#xml-3" class="headerlink" title="xml"></a>xml</h4><ul><li><p>用到参数类型UpdDTO，所以要将地址传入parameterType中。</p></li><li><p>将实体类所设计的字段全部进行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;updateEmpInfo&quot;</span> parameterType=<span class="string">&quot;com.example.test001.model.dto.EmpInfoUpdDTO&quot;</span>&gt;</span><br><span class="line">    update emp_manage.emp_info</span><br><span class="line">    set  no=#&#123;no&#125;,</span><br><span class="line"></span><br><span class="line">         name=#&#123;name&#125;,</span><br><span class="line"></span><br><span class="line">        phone=#&#123;phone&#125;,</span><br><span class="line"></span><br><span class="line">        idcard=#&#123;idcard&#125;,</span><br><span class="line"></span><br><span class="line">        org_id=#&#123;orgId&#125;,</span><br><span class="line"></span><br><span class="line">        crt_time=#&#123;crtTime&#125;,</span><br><span class="line"></span><br><span class="line">        salary=#&#123;salary&#125;,</span><br><span class="line"></span><br><span class="line">        position=#&#123;position&#125;,</span><br><span class="line"></span><br><span class="line">        use_flag=#&#123;useFlag&#125;</span><br><span class="line"></span><br><span class="line">    where id=#&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="员工管理模块、组织管理模块和账户管理模块"><a href="#员工管理模块、组织管理模块和账户管理模块" class="headerlink" title="员工管理模块、组织管理模块和账户管理模块"></a>员工管理模块、组织管理模块和账户管理模块</h2><ul><li>三种的增删改查功能、分页查询功能写法类似，主要注意表字段有哪几个</li><li>要求要看清，不能漏掉</li><li>此外账户管理模块还有要求，管理员重置其他用户密码功能和新增员工时自动创建账号，用户名为员工号，密码为身份证后6位。</li></ul><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><h4 id="controller类-4"><a href="#controller类-4" class="headerlink" title="controller类"></a>controller类</h4><ul><li>接口为put，且是根据id进行重置密码，设置注解@PutMapping(“&#x2F;reset&#x2F;{id}”)。</li><li>返回service的方法。</li></ul><h4 id="service接口类-3"><a href="#service接口类-3" class="headerlink" title="service接口类"></a>service接口类</h4><ul><li>方法类型boolean型。</li></ul><h4 id="serviceImpl实现类-4"><a href="#serviceImpl实现类-4" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>调用mapper中的方法。</li><li>返回true</li></ul><h4 id="mapper类-3"><a href="#mapper类-3" class="headerlink" title="mapper类"></a>mapper类</h4><ul><li><p>使用jet将用户信息加密到token中，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。</p></li><li><p>方法类型int，与前面实体类保持一致。</p></li></ul><h4 id="xml-4"><a href="#xml-4" class="headerlink" title="xml"></a>xml</h4><ul><li><p>由于没有resultType和parameterType，所以只需将mapper的方法传入。</p></li><li><p>重置密码是修改操作，使用update</p></li><li><p>根据id来设置密码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;resetPwd&quot;</span> &gt;</span><br><span class="line">    update emp_manege.user</span><br><span class="line">    <span class="type">set</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;hd000000&#x27;</span></span><br><span class="line">    <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="要求新增员工时自动创建账号，用户名为员工号，密码为身份证后6位"><a href="#要求新增员工时自动创建账号，用户名为员工号，密码为身份证后6位" class="headerlink" title="要求新增员工时自动创建账号，用户名为员工号，密码为身份证后6位"></a>要求新增员工时自动创建账号，用户名为员工号，密码为身份证后6位</h5><ul><li><p>在serviceImpl中实现这个方法</p></li><li><p>创建账户Account对象，将account掉换成addDTO，设置新增员工名字和登陆密码并调用</p></li><li><p>最终返回mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">addAccountInfo</span><span class="params">(AccountInfoAddDTO addDTO)</span>&#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    BeanUtils.copyProperties(addDTO, account);</span><br><span class="line">    account.setUsername(addDTO.getEmp_id().toString());</span><br><span class="line">    account.setPassword(StringUtils.substring(<span class="number">0</span>, addDTO.getCardId().length()-<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> accountInfoMapper.insertAccountInfo(addDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h2><h3 id="员工登录"><a href="#员工登录" class="headerlink" title="员工登录"></a>员工登录</h3><h4 id="controller类-5"><a href="#controller类-5" class="headerlink" title="controller类"></a>controller类</h4><ul><li>根据要求登陆页面输入账号密码调用登录接口，使用接口post，则注解为@PostMapping(“&#x2F;login”)。</li><li>登录是有前端传给后端，需要DTO类，声明username和password。</li><li>调用service方法。</li></ul><h4 id="service接口类-4"><a href="#service接口类-4" class="headerlink" title="service接口类"></a>service接口类</h4><ul><li>由于需要后端传给前端传递消息，还需创建tokenVo。</li></ul><h4 id="serviceImpl实现类-5"><a href="#serviceImpl实现类-5" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h4><ul><li>调用mapper的方法获取全部人员信息。</li><li>创建LoginTokenVo的对象。</li><li>进行for循环，循环所有的员工信息，如果登录使用账号密码都正确，则返回200</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>首先前端传东西给后端是通过接口传的，然后要看接口的参数是什么，有的是dto、有的是字段，也就是对应的DTO、Integer id那些。</li><li>然后到了controller这边以后，会往下走，就是看这个接口service调的什么方法了，就跳到了service里面。</li><li>到了service，就有他的impl实现类，这边经过业务逻辑，处理之后，就会给前端返回东西，也就是vo.</li></ol><ul><li>1.登录接口获取token<br>2.请求编辑接口（携带token）<br>3.接口获取token并获取该token对应的用户信息（user表）<br>4.user表获取role_id到role角色表中判断角色<br>5.角色-&gt;普通用户  编辑的username 是否和 此时登录的用户名相同。相同则可以编辑。（用汉字匹配石否有别的代替方法）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>员工管理系统</title>
      <link href="/2022/12/29/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/29/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>员工管理系统</p><p>数据库自己安装mysql5.6或5.7版本<br>接口调用使用postman<br>接口风格为restful,前后端分离结构，不要使用模板技术<br>一周时间做V1.0检查通过后做后面的。<br>可以百度搜资料，不建议直接复制黏贴，学习期间手敲代码为主。<br>common文件夹放常量类<br>controller文件夹放控制层类<br>entity文件夹放实体类<br>service文件夹放服务层接口<br>service.impl文件夹放接口实现类<br>mapper文件夹放数据层映射接口<br>util文件夹放工具类<br>员工表示例代码已创建，其他表自己学着做。</p><p>V1.0<br>新增模块：员工管理模块，组织管理模块</p><p>员工管理模块需求：<br>员工表字段：id 工号 姓名 手机号 身份证 所属组织id 入职时间 薪资 职位 是否有效<br>1.员工分页查询功能<br>2.员工增删改查功能</p><p>组织管理模块需求：<br>组织表字段：id 上级组织id 组织名 组织等级 组织负责人id 组织创建时间 是否有效<br>1.组织分页查询功能<br>2.组织增删改查功能</p><p>提示：<br>返回给页面数据时应当显示用户能看懂的内容，比如所属组织id应该显示所属组织的名称，<br>    时间一般转化为年月日的格式，以此类推不再举例。<br>使用mybatis 的xml文件手写sql，不要使用便捷搜索工具。<br>所有删除功能将是否有效改为无效，不需要数据库删除数据。下面不再说明。<br>工号唯一，手机号唯一，手机格式合理性校验，身份证格式合理性校验，薪资格式合理性校验<br>最上级组织的上级组织id为0</p><p>V1.1<br>新增模块：登录模块<br>登录页面输入账号密码调用登录接口，请求登录接口时读取resources文件夹下users.json文件的信息，判断账号密码是否正确，<br>正确的返回一个token给前端，<br>除了登录接口外，所有其他接口请求时判断token信息是否有效，无效的直接返回401状态。</p><p>提示：<br>token使用jwt工具（自学）<br>使用输入输出流读取文件内容转化为json格式数据（java基础），使用alibaba fastjson工具（自学）</p><p>V1.2<br>新增模块：账号管理模块<br>账号管理模块需求：<br>账号表字段：id 用户名 密码 真实姓名 员工id 账号创建时间 是否有效<br>1.账号分页查询功能<br>2.账号增删改查功能<br>3.管理员重置其他用户密码功能<br>4.新增员工时自动创建账号，用户名为员工号，密码为身份证后6位<br>提示：<br>编辑功能只有管理员账号可以，其他账号只能编辑自己。<br>密码需要加密后存入数据库。（加密方式自选自学）<br>登录接口时从此模块查询，取消文件读取方式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库软件</title>
      <link href="/2022/12/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/12/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><h2 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h2><pre><code>1. 安装2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\Data&quot;（隐藏文件ProgramData）    2. 卸载MySQL    3. 删除D:\Program Files目录下的MySQL文件夹3. 配置    * MySQL服务启动        1. 手动。计算机管理-&gt;服务和应用程序-&gt;服务        2. cmd-&gt;services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql:启动mysql的服务            * net stop mysql:关闭mysql的服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码        4. mysql -hlocalhost -uroot -p密码            * 设置时区，mysql本身时区是美国的                1. 查看：show variables like &#39;%time_zone&#39;;                2. 显示为system，设置时区：set global time_zone = ‘+8:00’;    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录            * 配置文件 my.ini        2. MySQL数据目录            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：</code></pre><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><pre><code>1. 什么是SQL？    * 结构化查询语言      其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称其&quot;方言&quot;。2. SQL通用语法    1. SQL语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。    4. 3种注释        * 单行注释：-- 注释内容 或 # 注释内容(MySQL特有)    (--后面一定要有空格)         * 多行注释：/* 注释 */ 3. SQL分类    1） DDL数据定义语言：用来定义数据库对象：数据库，表，列等。关键字：create,drop,alter等。    2） DML数据操作语言：用来对数据库中表的数据进行增删改。关键字：insert,delete,update等。    3） DQL数据查询语言：用来查询数据库中表的记录（数据）。关键字：selete,where等。    4） DCL数据控制语言：用来定义数据库的访问权限和安全级别及创建用户。关键字：GRANT,REVOKE等。</code></pre><h2 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集：            * create database 数据库名称 character set 字符集名;        * 练习：创建数据库，判断是否存在，并指定字符集为gbk            * create database if not exists db3 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称            * show databases;        * 查看某个数据库的字符集：查询某个数据库的创建语句            *  show create database 数据库名称;    3. U(Update)：修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete)：删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除：            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database()；        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法            * create table 表名(                列名1 数据类型1，                列名2 数据类型2，                ...                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号(,)            * 数据库类型：                1. int:整数类型                    * age int;                2. double:小数类型                    * score double(5,2)    (最大值为999.99)                3. date：日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒   yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型  包含年月日时分秒 yyyy-MM-dd  HH:mm:ss                    * 如果将来不给这个字段赋值，或赋值为null,则默认使用当前的系统时间，来自动赋值                6. varchar:字符串                    * name varchar(20):姓名最大20字符                    * zhangsan：8个字符  张三：2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int,                score double(4,1),                birthday date,                insert_type timestamp NOT NULL default CURRENT_TIMESTAMP            );        * 复制表：            * create table 表名 like 被复制的表名;    2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名；    3. U(Update)：修改        1. 修改表名            * alter table 表名 rename to 新的表名;        2. 修改表的字符集            * alter table 表名 character set 字符集的名称;        3. 添加一列            * alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            * alter table 表名 change 列名 新列名 新数据类型;            * alter table 表名 modify 列名 新数据类型;        5. 删除列            * alter table 表名 drop 列名;    4. D(Delete)：删除        * drop table 表名；        * drop table 表名 if exists 表名;    5. 使用数据库</code></pre><ul><li>客户端图形工具：SQLYog</li></ul><h2 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML:增删改表中数据"></a>DML:增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1，列名2，...列名n) values(值1，值2，...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名  values(值1，值2，...值n);        3. 除了数字类型，其他类型需要使用引号（单双）引起来2. 删除数据：    * 语法：        *delete from 表名 [where 条件];    * 注意：        1. 如果不加条件，则删除表中的所有记录。        2. 如果要删除所有记录            1. delete from 表名; --不推荐使用。有多少条记录就会执行多少次删除操作。            2. TRUNCATE TABLE 表名; --推荐使用，效率更高，先删除表，在创建一张一模一样的表。3. 修改数据：    * 语法：        * updete 表名 set 列名1 = 值1，列名2 = 值2，... [where 条件];    * 注意:        1. 如果不加任何条件，则会改变表中所有记录全部修改。</code></pre><h2 id="DQL-查询表中的记录"><a href="#DQL-查询表中的记录" class="headerlink" title="DQL:查询表中的记录"></a>DQL:查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询     1. 多个字段的查询     select 字段名1，字段名2... from 表名;        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。     2. 去除重复     * distinct     3. 计算列     * 一般可以使用四则运算来计算一些列的值。(一般只会进行数值型的计算)     * ifnull(表达式1，表达式2):     *表达式1：哪个字段需要判断是否是null            * 如果该字段为null后的替换值。     4. 起别名     * as:as也可以省略3. 条件查询     1. where子句后跟条件     2. 运算符     * &gt;， &lt;， &lt;=， &gt;=， =， &lt;&gt;     * between...and     * in(集合)     * like:模糊查询     * 占位符：     * _:单个任意字符     * %:多个任意字符     * is null     * and 或 &amp;&amp;     * or 或 ||     * not 或 !     SELECT * FROM student WHERE age &gt; 20;  -- 条件查询            SELECT * FROM student WHERE age &lt;&gt; 20; -- 不等于            SELECT * FROM student WHERE age BETWEEN 16 AND 30; -- 范围            SELECT * FROM student WHERE age IN (16,20);-- 单个            SELECT * FROM student WHERE english IS NULL; -- null查询            SELECT * FROM student WHERE english IS NOT NULL;-- 不为null            SELECT * FROM student WHERE NAME LIKE&#39;马%&#39;;  -- 第一个字是马            SELECT * FROM student WHERE NAME LIKE &#39;_化%&#39;; -- 第二个字是化            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;; -- 有三个字            SELECT * FROM student WHERE NAME LIKE&#39;%马%&#39;;  -- 包含马4. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1， 排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。5. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count:计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max:计算最大值    3. min:计算最小值    4. sum:计算和    5. avg:计算平均值    *注意：聚合函数的计算，排除了null值        * 解决方案：            1. 选择不包含非空的列进行计算            2. ifnull函数6. 分组查询:    1. 语法：group by 分组字段;    2. 注意：        1. 分组之后查询的字段：分组字段、聚合字段        2. where和having的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定。如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以跟聚合函数7. 分页查询    1. 语法：limit开始的索引，每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        SELECT * FROM student LIMIT 0,3;  -- 显示3条数据，第一页        SELECT * FROM student LIMIT 3,3;  -- 显示3条数据，第二页        SELECT * FROM student LIMIT 6,3;  -- 第三页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。* 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null    1. 创建表时添加约束        CREATE TABLE stu1(            id INT,            NAME VARCHAR(20) NOT NULL -- name非空        );    2. 创建表后，然后添加非空约束        ALTER TABLE stu1 MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu1 MODIFY NAME VARCHAR(20);* 唯一约束：unique，某一列的值不能重复    1. 注意：        * 唯一约束可以有null值，但是只能有一条数据为null    2. 创建表时添加唯一约束        * CREATE TABLE stu1(            id INT,            phone_number VARCHAR(20) UNIQUE -- 手机号        );    3. 删除唯一约束        * ALTER TABLE stu1 DROP INDEX phone_number;    4. 创建表后，然后添加唯一约束        * ALTER TABLE stu1 MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 创建表时添加主键约束        create table stu(            id int primary key, -- 给id添加主键约束            name varchar(20)        );    3. 删除主键        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建表后，然后添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1. 概念：如果某一列是数值类型，使用auto_increment 可以来完成值的自动增长        2. 创建表时添加主键约束，并且完成自动增长            create table stu(                id int primary key auto_increment, -- 给id添加主键约束                name varchar(20)            );        3. 删除自动增长            ALTER TABLE stu MODIFY id INT;        4. 创建表后，然后添加自动增长            ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key，让表与表产生关系，从而保证数据的正确性。     1. 在创建表时，可以添加外键     * 语法：     create table 表名(                ...                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);    4. 级联操作        1. 添加级联操作            * 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE;        2. 分类：            1. 级联更新：ON UPDATE CASCADE            2. 级联删除：ON DELETE CASCADE</code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系：    1.分类：        1. 一对一(了解)：            * 如： 人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三章中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。        3. 一对一(了解):            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式(1NF):每一列都是不可分割的原子数据项        2. 第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于码（1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B, 如果通过A属性（属性组）的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称）--&gt; 分数                2. 完全函数依赖：A--&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称）--&gt; 分数                3. 部分函数依赖：A--&gt;B，如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称）--&gt; 姓名                4. 传递函数依赖：A--&gt;B,B--&gt;C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递函数依赖与A。                    例如：学号-&gt;系名，系名-&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性值）为该表的码。                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式(3NF):在2NF基础上，任何非主属性不依赖于其他非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        *备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图像化工具</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        列明列表    where        ...* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept(NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);     # 创建员工表     CREATE TABLE emp(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1),  -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY(dept_id) REFERENCES dept(id) -- 外键，关联部门表（部门表的主键）     );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES (&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES (&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-01&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES (&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES (&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES (&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B。取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据。* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：                -- 查询所有员工信息和对应的部门信息                    SELECT * FROM dept, emp WHERE emp.`dept_id` = dept.`id`;                -- 查询员工表的名称，性别，部门表的名称                    SELECT                      t1.`name`, -- 员工表的姓名                      t1.`gender`, -- 员工表的性别                      t2.`name` -- 部门表的名称                    FROM                      emp t1,                      dept t2                    WHERE t1.`dept_id` = t2.`id`        2. 显式内连接：            * 语法：select 字段列表 from 表名 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                * SELECT * FROM emp JOIN  dept ON emp.`dept_id` = dept.`id`;        3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外连接查询：        1. 左外连接            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 表1            * 查询的是左表所有数据以及其交集部分。        2. 右外连接            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 表1            * 查询的是右表所有数据以及其交集部分。    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 1.查询最高的工资是多少9000            SELECT MAX(salary) FROM emp;                            -- 2.查询员工信息并且工资为9000            SELECT * FROM emp WHERE emp.`salary` = 9000;                            -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);         * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。运算符： &gt;, &gt;=, &lt;, &lt;=, =                    -- 查询员工工资小于平均工资的人                    SELECT * FROM emp WHERE emp.`salary` &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in去判断。                    -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有员工的信息                    SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME IN (&#39;财务部&#39;,&#39;市场部&#39;));            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询。                    -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                    SELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2 WHERE t1.`id` = t2.dept_id;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么成功，要么同时失败。、    2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account(            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME,balance) VALUES (&#39;张三&#39;,1000),(&#39;李四&#39;,1000);                SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账500元                -- 0.开启事务        START TRANSACTION;        -- 1.张三转账-500        UPDATE account SET balance = balance-500 WHERE NAME = &#39;张三&#39;;        -- 2.李四账户+500        -- 出错了        UPDATE account SET balance = balance+500 WHERE NAME = &#39;李四&#39;;        -- 发现执行没有问题，提交事务        COMMIT;        -- 发现出现错误。回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交        * 事务提交的两种方式            * 自动提交：                * MySQL就是自动提交的                * 一条DML（增删改）语句会自动提交一次事务。            * 手动提交：                * Oracle数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：select @@autocommit; -- 1 代表自动提交 0 代表手动提交            * 修改默认提交方式：set @@autocommit = 02. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间相互独立。    4. 一致性：事务操作前后，数据总量不变。3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据。        2. 不可重复读（续读）：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted:读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed:读已提交（Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read:可重复读（MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level 级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL:"></a>DCL:</h2><pre><code>* SQL分类：    1. DDL:操作数据库和表    2. DML:增删改表中数据    3. DQL:查询表中数据    4. DCL:管理用户，授权* DBA：数据库管理员* DCL:管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户:            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码:            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;)WHERE USER = &#39;用户名&#39;;FLUSH PRIVILEGES;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39; ;FLUSH PRIVILEGES;            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;wlm&#39;@&#39;主机名&#39; = PASSWORD(&#39;abc&#39;);            ALTER USER &#39;用户名&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;            ALTER USER &#39;wlm&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;abc&#39;;            * MySQL中忘记了root用户的密码？                1. cmd-&gt;net stop mysql 停止mysql服务                    * 需要管理员运行cmd                2. 使用无验证方式启动MySQL服务：mysqld --skip-grant-tables                3. 打开新的cmd窗口，直接输入MySQL命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;)where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe的进程                8. 启动MySQL服务  net start mysql                9. 使用新密码登录        4. 查询用户            -- 1.切换到MySQL数据库            use mysql;            -- 2.查询user表            select * from user;            * 通配符：% 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限:            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;wlm&#39;@&#39;localhost&#39;;        2. 授予权限            GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;            GRANT SELECT ON db3.`account` TO &#39;wlm&#39;@&#39;localhost&#39;;            -- 授予所有权限            GRANT ALL ON *.* TO &#39;wlm&#39;@&#39;localhost&#39;;        3. 撤销权限            REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;wlm&#39;@&#39;localhost&#39;;</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity Java数据库连接，Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包   mysql-connector-java-5.0.8-bin.jar            1. 复制mysql-connector-java-5.0.8-bin.jar到项目的libs目录下            2. 右键--&gt;add as library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接收返回结果        7. 处理结果        8. 释放资源    * 代码实现:        // 1. 导入驱动jar包        // 2. 注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        // 3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);        // 4. 定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        // 5. 获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        // 6.执行sql        int count = stmt.executeUpdate(sql);        // 7.处理结果        System.out.println(count);        // 8.释放资源        conn.close();        stmt.close();3. 详解各个对象    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动                static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager。                写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                static&#123;                    try&#123;                        java.sql.DriverManager.registerDriver(new Driver());                    &#125;catch(SQLException E)&#123;                        throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                    &#125;                &#125;                注意：MySQL5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://IP地址（域名）：端口号/数据库名称?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8                        * 例子：jdbc:mysql://localhost:3306/db3?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8                        * 细节：如果连接的是本机MySQL服务器，并且MySQL服务默认端口是3306，则url可以简写为                            jdbc:mysql:///数据库名称?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8                    * user:用户名                    * password:密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql的对象                * Statement createStatement()                  * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit)  ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                  * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql)  ：可以执行任意的sql  了解            2. int executeUpdate(String sql)  ：执行DML（insert、update、delete）语句、DDL（create、alter、drop）语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功  返回值&gt;0的则执行成功，反之执行失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select）语句        2. 练习：            1. account表  添加一条数据            2. account表  修改记录            3. account表  删除一条数据                语句：                Statement stmt = null;                Connection conn = null;                try &#123;                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null, &#39;王五&#39;, 3000)&quot;;                    //3. 获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);                    //4. 获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5. 执行sql                    int  count = stmt.executeUpdate(sql);//影响行数                    //6. 处理结果                    System.out.println(count);                    if (count &gt; 0)&#123;                        System.out.println(&quot;执行成功&quot;);                    &#125;else&#123;                        System.out.println(&quot;执行失败&quot;);                    &#125;                &#125; catch (ClassNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //7. 释放资源                    if (stmt != null)&#123;                        try &#123;                            stmt.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                            if (conn != null)&#123;                        try &#123;                            conn.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;    4. ResultSet：结果集对象，封装查询结果        * Boolean next() ：游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据），如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx:代表数据类型  如：int getInt(),  String getString()            * 参数：                1. int:代表列的编号,从1开始  如：getString(1)                2. String:代表列名称。  如：getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据                    //循环判断游标是否是最后一行末尾                    while(rs.next())&#123;                        //获取数据                        //6.2 获取数据                        int id = rs.getInt(1);                        String name = rs.getString(&quot;name&quot;);                        double balance = rs.getDouble(3);                        System.out.println(id + &quot;----&quot; + name + &quot;----&quot; + balance);                    &#125;            * 练习：                * 查询emp表的数据将其分装为对象。然后装载集合，返回。                    1. 定义Emp类                    2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;                    3. 实现方法 select * from emp    5. PreparedStatement：执行sql对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql:select * from user where username = &#39;dnciajoakszpam&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;        2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用 ？作为占位符        4. 步骤：            1. 导入驱动jar包   mysql-connector-java-5.0.8-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。如:select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)              6. 给？赋值：                * 方法：setXXX(参数1，参数2)                    * 参数1：？的位置编号，从1开始                    * 参数2：？的值            6. 执行sql，接收返回结果，不需要传递sql语句            7. 处理结果            8. 释放资源        5. 注意:后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高            </code></pre><h2 id="抽取JDBC工具类：JDBCUtils"><a href="#抽取JDBC工具类：JDBCUtils" class="headerlink" title="抽取JDBC工具类：JDBCUtils"></a>抽取JDBC工具类：JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源            public List&lt;Emp&gt; findAll2() &#123;                Connection conn = null;                Statement stmt = null;                ResultSet rs = null;                List&lt;Emp&gt; list = null;                try &#123;                    conn = JDBCUtils.getConnection();                    //3. 定义sql                    String sql = &quot;select * from emp&quot;;                    //4. 获取执行sql的对象                    stmt = conn.createStatement();                    //5. 执行sql                    rs = stmt.executeQuery(sql);                    //6. 遍历结果集，封装对象，装载集合                    Emp emp = null;                    list = new ArrayList&lt;Emp&gt;();                    while (rs.next()) &#123;                        //获取数据                        int id = rs.getInt(&quot;id&quot;);                        String ename = rs.getString(&quot;ename&quot;);                        int job_id = rs.getInt(&quot;job_id&quot;);                        int mgr = rs.getInt(&quot;mgr&quot;);                        Date joinDate = rs.getDate(&quot;joinDate&quot;);                        double salary = rs.getDouble(&quot;salary&quot;);                        double bonus = rs.getDouble(&quot;bonus&quot;);                        int dept_id = rs.getInt(&quot;dept_id&quot;);                        //创建emp对象                        emp = new Emp();                        emp.setId(id);                        emp.setEname(ename);                        emp.setJob_id(job_id);                        emp.setMgr(mgr);                        emp.setJoindate(joinDate);                        emp.setSalary(salary);                        emp.setBonus(bonus);                        emp.setDept_id(dept_id);                        //装载集合                        list.add(emp);                    &#125;                &#125;catch (SQLException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                   JDBCUtils.close(rs,stmt,conn);                        &#125;                return list;            &#125;* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登陆成功            * select * from user where username = &quot;&quot; and password =&quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败。    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );                        INSERT INTO USER VALUES(NULL,&#39;张三&#39;,123);            INSERT INTO USER VALUES(NULL,&#39;李四&#39;,234);        2. public static void main(String[] args) &#123;            //1. 键盘录入，接收用户名和密码            Scanner sc = new Scanner(System.in);            System.out.println(&quot;请输入账号&quot;);            String username = sc.nextLine();            System.out.println(&quot;请输入密码&quot;);            String password = sc.nextLine();            //2. 调用方法            boolean flag = new JDBCDemo9().login2(username, password);            //3. 判断结果，输出不同语句            if (flag)&#123;                System.out.println(&quot;登陆成功！&quot;);            &#125;else&#123;                System.out.println(&quot;用户名或密码错误！&quot;);            &#125;        &#125;        /**         * 登陆方式         */        public boolean  login(String username, String password)&#123;            if (username == null || password == null)&#123;                return false;            &#125;            // 连接数据库判断是否登陆成功            Connection conn = null;            Statement stmt = null;            ResultSet rs = null;            try &#123;                //1. 获取连接                conn = JDBCUtils.getConnection();                //2. 定义sql                String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39;&quot;;                //3. 获取执行sql的对象                stmt = conn.createStatement();                //4. 执行查询                rs = stmt.executeQuery(sql);                //5. 判断                return rs.next();// 如果有下一行，则返回true            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(rs,stmt,conn);            &#125;                    return false;        &#125;</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit)  ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()          * 在所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务        </code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器（集合），存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource javax.sql包下的        1. 方法            * 获取连接：getCommection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接。    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0:数据库连接池技术        2. Druid:数据库连接池实现技术，右阿里巴巴提供的4. C3P0:数据库连接池技术    * 步骤：        1. 导入jar包（两个）c3p0-0.9.5.2.jar  mchange-commons-java-0.2.12.jar            * 不要忘记导入数据库驱动jar包                * 注意：                    mysql，Tomcat版本不同，需要匹配相应高的版本        2. 定义配置文件：            * 名称：c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象  数据库连接池对象  ComboPooledDataSource        4. 获取连接：getConnection5. Druid:数据库连接池实现技术，右阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂类来获取  DruidDataSourceFactory        5. 获取连接：getConnection    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法                public static void main(String[] args) &#123;                Connection conn = null;                PreparedStatement pstmt = null;                /**                 * 完成添加操作：给account表添加一条记录                 */                try &#123;                    //1. 获取连接                    conn = JDBCUtils.getConnection();                    //2. 定义sql                    String sql = &quot;insert into account values(null, ?, ?)&quot;;                    //3. 获取pstmt对象                    pstmt = conn.prepareStatement(sql);                    //4. 给？赋值                    pstmt.setString(1,&quot;王五&quot;);                    pstmt.setDouble(2,1000);                    //5. 执行sql                    int count = pstmt.executeUpdate();                    System.out.println(count);                        &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //释放资源                    JDBCUtils.close(pstmt,conn);                &#125;            &#125;</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JDBCTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 使用JdbcTemplate方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value，将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject:查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查村所有记录，将其封装为List集合            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数</code></pre><h2 id="Web概念概述"><a href="#Web概念概述" class="headerlink" title="Web概念概述"></a>Web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S:Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ、迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发，安装，部署，维护 麻烦    2. B/S:Brower/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序        * 优点：            1. 开发，安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术分布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本、图片、音频、视频，HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源。        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样...                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示网页的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果    </code></pre><p><strong>暂停学习P115已学完！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/12/29/Maven/"/>
      <url>/2022/12/29/Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><pre><code>1. Maven是什么    * Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）    * POM（Project Object Model）：项目对象模型2. Maven的作用    * 项目构建：提供标准的、跨平台的自动化项目构建方式    * 依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题    * 统一开发结构：提供标准的、统一的项目结构3. Maven基础概念    1. 仓库        1. 仓库：用于存储资源，包含各种jar包        2. 仓库分类：            1. 本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源            2. 远程仓库：非本机电脑上的仓库，为本地仓库提供资源                * 中央仓库：Maven团队维护，存储所有资源的仓库                * 私服：部门/公司范围内存储资源的仓库，从中央仓库获取资源        3. 私服的作用：            * 保存具有版权的资源，包含购买或自主研发的jar                * 中央仓库中的jar都是开源的，不能存储具有版权的资源            * 一定范围内共享资源，仅对内部开放，不对外共享    2. 坐标        1. 概念：Maven中的坐标用于描述仓库中资源的位置        2. Maven坐标主要组成            * groupId：定义当前Maven项目隶属组织名称                * 注意：通常是域名反写                * 例如：org.mybatis            * artifactId:定义当前Maven项目名称                * 通常是模块名称                * 例如：CRM,SMS            * version:定义当前项目版本号            * packaging:定义该项目的打包方式        3. Maven坐标的作用            使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</code></pre><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><pre><code>1. 依赖配置    * 概念：依赖指当前项目运行所需的jar，一个项目可以设置多个依赖    * 格式：          &lt;!--  设置当前项目所依赖的所有jar--&gt;          &lt;dependencies&gt;            &lt;!--具体依赖--&gt;            &lt;dependency&gt;              &lt;!--依赖所属群组id --&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;!-- 以来所属项目id--&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;!--依赖版本号--&gt;              &lt;version&gt;4.12&lt;/version&gt;            &lt;/dependency&gt;          &lt;/dependencies&gt;2. 依赖传递    1. 依赖具有传递性        * 直接依赖：在当前项目中通过依赖配置建立的依赖关系        * 间接依赖：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源        * 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的    2. 依赖传递冲突问题        * 路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高        * 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后        * 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的3. 可选依赖    * 概念：可选依赖指对外隐藏当前所依赖的资源--不透明。    * 示例：           &lt;dependency&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;version&gt;4.11&lt;/version&gt;              &lt;optional&gt;true&lt;/optional&gt;            &lt;/dependency&gt;4. 排除依赖    * 概念：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本--不需要    * 示例：        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;                    &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;5. 依赖范围    * 概念：依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围    * 作用范围：        * 主程序范围有效（main文件夹范围内）        * 测试程序范围有效（test文件夹范围内）        * 是否参与打包（package指令范围内）6. 依赖范围的传递性    * 概念：带有依赖范围的资源在进行传递时，作用范围将受到影响</code></pre><p>|         | compile | test  |provided  |runtime  |  &lt;–直接依赖<br>| ——–|:——-:| —–:|———:|——–:|<br>| compile | compile | test  |          |runtime  |<br>| test    |         |       |          |         |<br>| provided|         |       |          |         |<br>| runtime | runtime |  test |          | runtime |<br> ↑  间接依赖 </p><h2 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h2><pre><code>1. 项目构建生命周期    * Maven对项目构建的生命周期分为3套        * clean:清理工作        * defaul:核心工作，例如编译，测试，打包，部署等        * site:产生报告，发布地点等2. 插件        * 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能        * 默认maven在各个生命周期上绑定有预设的功能        * 通过插件可以自定义其他功能</code></pre><h2 id="分模块开发与设计"><a href="#分模块开发与设计" class="headerlink" title="分模块开发与设计"></a>分模块开发与设计</h2><pre><code>1. 工程模块与模块划分</code></pre><p>**<br>学完SSM继续学！！！P14已学完**</p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统配置</title>
      <link href="/2022/12/29/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/12/29/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="jdk安装-配置"><a href="#jdk安装-配置" class="headerlink" title="jdk安装+配置"></a>jdk安装+配置</h2><ol><li>在命令窗口键入java -version，出现command not found，表示没有jdk在里面</li></ol><pre><code>![image-20221114100942894](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114100942894.png)</code></pre><ol start="2"><li><p>创建一个java目录：mkdir -p &#x2F;java</p></li><li><p>进入目录：cd &#x2F;java</p></li></ol><pre><code>![image-20221114102127398](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102127398.png)</code></pre><ol start="4"><li>通过rz命令或xftp将下载的jdk包上传到该目录</li></ol><pre><code>![image-20221114102153005](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102153005.png)</code></pre><ol start="5"><li>解压jdk压缩包：tar -zxvf jdk-8u351-linux-x64.tar.gz</li></ol><pre><code>![image-20221114102216045](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102216045.png)</code></pre><ol start="6"><li>配置环境变量</li></ol><pre><code>用vim或vi 打开/etc/profile 文件![image-20221114102502681](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102502681.png)</code></pre><ol start="7"><li>点击键盘 <code>i</code> 进行编辑，将下面内容粘贴到末尾，注意export JAVA_HOME&#x3D;&#x2F;java&#x2F;jdk1.8.0_351就是你自己的jdk目录</li></ol><pre><code>export JAVA_HOME=/java/jdk1.8.0_351export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar![image-20221114102737017](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102737017.png)</code></pre><ol start="8"><li>保存修改</li></ol><pre><code>1. Esc2. Shift + q 进入键盘编辑3. wq 保存并退出   ![image-20221114102945777](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114102945777.png)</code></pre><ol start="9"><li><p>重新加载配置文件：source &#x2F;etc&#x2F;profile </p></li><li><p>验证安装情况</p></li></ol><pre><code> 输入:java -version ![image-20221114103138541](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114103138541.png) 输入:javac ![image-20221114103241417](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114103241417.png) 输入：java ![image-20221114103341412](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114103341412.png)</code></pre><ol start="11"><li>如上所示，JDK已经安装完成了！！！</li></ol><h2 id="Docker安装-配置"><a href="#Docker安装-配置" class="headerlink" title="Docker安装+配置"></a>Docker安装+配置</h2><ol><li>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</li></ol><pre><code>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine \                  docker-ce![image-20221114103754017](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114103754017.png)</code></pre><ol start="2"><li>首先需要虚拟机联网，安装yum工具，直到出现Complete!结束：</li></ol><pre><code>yum install -y yum-utils \           device-mapper-persistent-data \           lvm2 --skip-broken![image-20221114104449905](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114104449905.png)</code></pre><ol start="3"><li>然后更新本地镜像源：</li></ol><pre><code>1. 设置docker镜像源：   yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo2.  sed -i &#39;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repo3.  yum makecache fast&lt;img src=&quot;C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114104826663.png&quot; alt=&quot;image-20221114104826663&quot; style=&quot;zoom:100%;&quot; /&gt;</code></pre><ol start="4"><li>然后输入命令：yum install -y docker-ce，docker-ce为社区免费版本。稍等片刻，出现Complete!，docker即可安装成功。</li></ol><pre><code>![image-20221114104955515](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114104955515.png)</code></pre><ol start="5"><li><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><pre><code>   1. 关闭：systemctl stop firewalld   2. 禁止开机启动防火墙：systemctl disable firewalld   3. 查看是否关闭防火墙：systemctl status firewalld</code></pre></li></ol><pre><code>![image-20221114105158048](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114105158048.png)</code></pre><ol start="6"><li>通过命令启动docker：</li></ol><pre><code>1. 启动docker服务：systemctl start docker2. 停止docker服务：systemctl stop docker3. 重启docker服务：systemctl restart docker   ![image-20221114105422048](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114105422048.png)4. 输入验证启动成功命令：systemctl status docker，当出现active（running）时，即为启动成功，如图：   ![image-20221114105455662](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114105455662.png)</code></pre><ol start="7"><li>查看docker版本：docker -v</li></ol><pre><code>![image-20221114105540340](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114105540340.png)</code></pre><ol start="8"><li>配置镜像加速，创建文件夹：sudo mkdir -p &#x2F;java&#x2F;docker</li></ol><pre><code>1. 在文件夹内新建一个daemon.json文件   sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; &#123;  &quot;registry-mirrors&quot;: [&quot;https://akchsmlh.mirror.aliyuncs.com&quot;] &#125; EOF2. 重新加载文件   sudo systemctl daemon-reload3. 重启docker   sudo systemctl restart docker![image-20221114105800279](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114105800279.png)到此Docker的安装就基本结束了!!!</code></pre><h3 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h3><ol><li>查看自己服务器中docker 镜像列表:docker images</li></ol><p>   <img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114110020619.png" alt="image-20221114110020619"></p><ol start="2"><li><p>拉取镜像：</p></li><li><p>docker pull 镜像名</p></li><li><p>docker pull 镜像名:tag</p></li></ol><p>   不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本</p><p>   <img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114110122692.png" alt="image-20221114110122692"></p><ol start="3"><li><p>保存镜像</p></li><li><p>docker save 镜像名&#x2F;镜像ID -o 镜像保存的名字 镜像保存的tag，例如：docker save -o redis.tar redis:latest</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114110234481.png" alt="image-20221114110234481"></p></li><li><p>删除镜像：docker rmi -f 镜像名&#x2F;镜像ID</p></li></ol><p>   <img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114110320989.png" alt="image-20221114110320989"></p><ol start="5"><li>加载镜像：docker load -i 镜像保存文件位置，例如：例如：docker load -i redis.tar</li></ol><p>   <img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221114110410492.png" alt="image-20221114110410492"></p><h2 id="Docker部署idea项目"><a href="#Docker部署idea项目" class="headerlink" title="Docker部署idea项目"></a>Docker部署idea项目</h2><ol><li><p>首先服务器，要配置安全组，开放2375端口。</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115112656852.png" alt="image-20221115112656852"> </p></li><li><p>进入实例中，运用这个安全组。可以使用cmd查看是否连接上了。cmd -&gt; telnet 公网IP 端口号。</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115112820878.png" alt="image-20221115112820878"></p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115112958042.png" alt="image-20221115112958042"></p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115113048385.png" alt="image-20221115113048385"></p></li><li><p>查询docker服务：systemctl status docker.service。</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115113421056.png" alt="image-20221115113421056"></p></li><li><p>docker文件配置：docker.service文件（所在目录 ： &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service），修改内容如下：</p><ol><li><p>Docker是默认拒绝连接的，需开放连接docker端口：</p><p>-H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115114518746.png" alt="image-20221115114518746"></p></li><li><p>重新载入服务信息：systemctl daemon-reload</p></li><li><p>重启docker服务：systemctl restart docker</p></li></ol></li><li><p>查看端口是否开启 ：netstat -nlpt</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115135123709.png" alt="image-20221115135123709"></p></li><li><p>配置docker的IDEA相关配置，下载docker插件，然后重启IDEA。</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115135357755.png" alt="image-20221115135357755"></p></li><li><p>在setting中设置Docker相关配置， Engine API URL就是你的Docker服务器的ip+端口2375， 看到Connection successful的字样，即表示连接成功。</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221115135632660.png" alt="image-20221115135632660"></p></li><li><p>IDEA操作Docker管理工具。</p><p>如图：IDEA中Run –&gt; Edit Configurations，选择+，然后填写相关的配置。</p><p>Name：Run&#x2F;Debug Configuration的名称</p><p>Server：上一步添加的Docker server</p><p>Dockerfile：project对应的dockerfile文件</p><p>Context folder：project目录，因为一般把Dockerfile放在和pom同目录，所以也就是dockerfile目录</p><p>Image tag：生成image名称</p><p>Container name：运行生成的容器名称，勾选☑️Run built image</p><p>Bind ports：端口映射</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116103657558.png" alt="image-20221116103657558"></p></li><li><p>开始运行。</p></li><li><p>docker运行容器命令，勾上Run build image , 写上端口映射和容器名字，然后就可以运行了。不出意外：成功运行。</p></li><li><p>或者获取正在运行的容器ID：docker ps</p></li></ol><pre><code>  复制容器ID并查询： docker inspect &lt;容器ID&gt;  错误解析：  1.  反复出现You have new mail in /var/spool/mail/root     解决方案：关闭提示：（在root下）     echo &quot;unset MAILCHECK&quot; &gt;&gt; /etc/profile     source /etc/profile  2.    3.    4. </code></pre><h3 id="Dockerfile基础使用"><a href="#Dockerfile基础使用" class="headerlink" title="Dockerfile基础使用"></a>Dockerfile基础使用</h3><ol><li><p>基础须知</p><p>指令是不区分大小写，但是为了和参数区域区别开来，所以约定指令区是大写的。<br>指令是按顺序运行，必须以FROM指令开头，#作为注释，每行只支持一条指令，—条指令可以携带多个参数。<br>Dockerfile指令分为构建和设置指令:构建指令用于构建镜像，指定的操作不会在镜像的容器里执行。设置指令是用于设置镜像的属性，这指定的操作会在镜像的容器里执行命令。</p></li><li><p>dockerfile常用指令</p><p>FROM 指明是基于那个镜像<br>LABEL标签<br>RUN构建镜像时运行的shell命令<br>COPY 复制文件到镜像中<br>ADD解压压缩包并复制<br>ENV设置环境变量<br>USER指明运行RUN、CMD、ENTRYPOINT命令时的执行用户<br>EXPOSE暴露容器运行的服务端口<br>WORKDIR为RUN、CMD、COPY、 ADD、ENTRYPOINT指定工作目录<br>CMD运行容器时执行，多个只执行最后一个</p></li><li><p>部分命令详解</p><ol><li><p>FROM</p><p>指定基础镜像，在此镜像基础上修改数据构建新镜像，可以是本地仓库也可以是远<br>程仓库<br>格式:FROM【本地仓库、远程仓库】image名字(默认最新版本)或FROMimage: tag(指定版本)</p></li><li><p>RUN</p><p>运行基础镜像支持的命令，可以使用多条，指令长可以使用反斜杠黄航<br>格式: RUN命令command (-bin&#x2F;sh -c)或RUN<a href="%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96shell%E7%BB%88%E7%AB%AF">“&#x2F;bin&#x2F;bash” ,”-c” ,”echo hellocillian”</a></p></li><li><p>COPY</p><p>复制本地文件到容器内，目标路径不存在会自动创建<br>格式: COPY cillian&#x2F;test1 test<br>注意:这个功能只能用于构建linux容器的dockefile上支持，windows容器上不起作用，运维用户和组的概念在linux和windows之间没法转换，所以仅只用于基于linux系统的容器。</p></li><li><p>WORKDIR</p><p>类似cd命令，为RUN、CMD、ENTRYPOINT配置工作目录，可以使用多个<br>WORKDIR命令，如果后续命令不是绝对路径，就是按照上一级路径的基础上执行</p></li><li><p>ENTRYPOINT</p><p>指定容器启动时执行的命令，多次设置只执行最后一次，被翻译为进入点，这个功能让它像一个可执行程序。<br>格式:ENTRYPOINT [“executable”, “param1”, “param2”]<br>例:ENTRYPOINT [“&#x2F;usr&#x2F;bin&#x2F;ls”,”-a”]<br>CMD[“-&#x2F;“]<br>或ENTRYPOINT command param1 param2 (as a shell)<br>例:ENTERPOINT ls -l</p></li><li><p>EXPOSE</p><p>让容器在运行时，监听指定端口，默认TCP协议，会将容器中的端口映射为宿主机中的端口，通过宿主机ip和映射后的端口可以访问容器，因为可以避免容器每次运行时的ip随机生成不固定的问题。运行容器上加参数-p指定设置的端口，例如-p9001:80容器80端口映射为宿主机9001端口<br>格式:EXPOSE port</p></li><li><p>ENV</p><p>在镜像中设置环境变量，设置之后RUN就可以使用这个环境变量<br>格式:ENV JAVA_HOME&#x2F;opt&#x2F;java</p></li></ol></li><li><p>构建镜像命令</p><p>Docker build -t [options] path|url -flags<br>-t –tag list镜像名称<br>-f-file string指定dockerfile文件位置<br>例: docker build-t cillian&#x2F;docker -f &#x2F;cillian&#x2F;dockerfile</p></li><li><p>构建nginx镜像</p><p>FROM centos:7<br>LABEL maintainer <a href="http://www.ctnrs.com/">www.ctnrs.com</a><br>RUN yum install -y gcc gcc-C++ make <br>openssl-devel pcre-devel gd-devel <br>iproute net-tools telnet wget curl &amp;&amp; <br>yum clean all &amp;&amp; <br>rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;*<br>ADD nginx-1.15.5.tar.gz <br>RUN cd nginx-1.15.5 &amp;&amp; <br>.lconfigure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx <br>–with-http_ssl_module <br>–with-http_stub_status_module &amp;&amp; <br>make -j 4 &amp;&amp; make install &amp;&amp; <br>mkdir &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;vhost &amp;&amp; <br>cd &#x2F; &amp;&amp; rm -rf nginx*&amp;&amp; \</p><p>ln -sf &#x2F;usrlshare&#x2F;zoneinfolAsia&#x2F;Shanghai &#x2F;etc&#x2F;localtime<br>ENV PATH $PATH:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin<br>COPY nginx.conf &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>WORKDIR&#x2F;usr&#x2F;local&#x2F;nginx<br>EXPOSE 80<br>CMD [“nginx”, “-g”, “daemon off;”]</p></li></ol><h2 id="Docker部署springboot项目（网桥模式）"><a href="#Docker部署springboot项目（网桥模式）" class="headerlink" title="Docker部署springboot项目（网桥模式）"></a>Docker部署springboot项目（网桥模式）</h2><ol><li><p>创建自定义网桥并查看</p></li><li><p>docker network create 名字</p></li><li><p>docker network ls</p></li></ol><p>   <img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116114217717.png" alt="image-20221116114217717"></p><ol start="2"><li><p>安装配置Redis</p></li><li><p>安装redis依赖：Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖，出现complete!即完成：</p><p>yum install -y gcc tcl</p><p><img src="C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116141143353.png" alt="image-20221116141143353"></p></li><li><p>上传安装包并解压：这里选择Linux版本为CentOS 7或者是自己选择版本，官方链接：<a href="https://redis.io/download/">Download | Redis</a></p></li></ol><pre><code>  ![image-20221116141426963](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116141426963.png)  ![image-20221116145110536](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116145110536.png)</code></pre><ol start="3"><li>解压命令，这里用绝对路径：tar -zvxf &#x2F;java&#x2F;redis-5.0.14.tar.gz</li></ol><pre><code>  ![image-20221116145321575](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116145321575.png)</code></pre><ol start="4"><li>删除压缩包：rm  &#x2F;java&#x2F;redis-5.0.14.tar.gz</li></ol><pre><code>  ![image-20221116145420678](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116145420678.png)</code></pre><ol start="5"><li>如果是自己写的，确定在当前目录下；如果是源码安装，先运行.&#x2F;configure，生成makefile，再执行make，即可正常运行。按顺序执行以下命令安装 ncurses：</li></ol><pre><code>  1. wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.6.tar.gz  2. tar zxvf ncurses-5.6.tar.gz  3. cd ncurses-5.6  4.  ./configure -prefix=/java -with-shared -without-debug  5. make  6. make install  ![image-20221116154249918](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116154249918.png)  ![image-20221116154316426](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116154316426.png)  ![image-20221116154344010](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116154344010.png)  ![image-20221116154404552](C:\Users\wlm\AppData\Roaming\Typora\typora-user-images\image-20221116154404552.png)</code></pre><ol start="3"><li><p>启动redis（默认已经有镜像）</p><p>docker run -d -p 6379:6379 –name redis –restart always –network test redis</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/2022/12/29/SSM/"/>
      <url>/2022/12/29/SSM/</url>
      
        <content type="html"><![CDATA[<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><pre><code>1. 代码书写现状    * 耦合度偏高。    1. 解决方案        * 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象。2. IoC(Inversion of Control)控制反转    * 概念：使用对象时，由主动new产生对象转换为由外部提供对象。此过程中对象的创建控制权由程序转移到外部，这种思想称为控制反转。    * Spring技术对IoC思想进行了实现。        * Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的&quot;外部&quot;。        * IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean。3. DI(Dependency Injeection)依赖注入    * 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。4. 目标：充分解耦    * 使用IoC容器管理bean(IoC)。    * 在IoC容器内将有依赖关系的bean进行关系绑定(DI)。5. 最终效果    * 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。</code></pre><h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><pre><code>1. bean基础配置    1. 别名：id,class    2. 功能：定义spring核心容器管理的对象        * 例：&lt;bean id =&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;            * id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一            * class：bean的类型，即配置的bean的全路径类名2. bean别名配置    1. 别名：name    2. 功能：定义bean的别名，可定义多个，使用逗号分号空格分隔        * 例： &lt;bean id =&quot;bookDao&quot; name=&quot;dao dao2 abc&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;    3. 注意：        * 获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException            * NoSuchBeanDefinitionException: No bean named &#39;service4&#39; available3. bean作用范围配置    1. 别名：scope    2. 功能：定义bean的作用范围，可选范围有：singleton（单例（默认）），prototype（非单例）        * 例：&lt;bean id =&quot;bookDao&quot; name=&quot;dao dao2 abc&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;    3. 说明：        * 适合交给容器进行管理的bean            * 表现层对象            * 业务层对象            * 数据层对象            * 工具对象        * 不适合交给容器进行管理的bean            * 封装实体的域对象4. 实例化bean的三种方式    1. 构造方法（常用）        * 提供可访问的构造方法            public class BookDaoImpl implements BookDao &#123;                public BookDaoImpl()&#123;                    System.out.println(&quot;book dao constructor is running ...&quot;);                &#125;                            public void save()&#123;                    System.out.println(&quot;book dao save ...&quot;);                &#125;            &#125;        * 配置不变        * 无参构造方法如果不存在，将抛出异常BeanInstantiationException    2. 静态工厂（了解）        * public class OrderDaoFactory &#123;            public static OrderDao getOrderDao()&#123;                return new OrderDaoImpl();            &#125;        &#125;        * 配置            * &lt;bean id=&quot;orderDao&quot; factory-method=&quot;getOrderDao&quot; class=&quot;com.itheima.factory.OrderDaoFactory&quot;/&gt;    3. 实例工厂（了解）        * public class UserDaoFactory &#123;            public UserDao getUserDao()&#123;                return new UserDaoImpl();            &#125;        &#125;        * 配置            * &lt;bean id=&quot;userFactory&quot; class=&quot;com.itheima.factory.UserDaoFactory&quot;/&gt;                 &lt;bean id=&quot;userDao&quot; factory-method=&quot;getUserDao&quot; factory-bean=&quot;userFactory&quot;/&gt;    4. FactoryBean（实用）        * public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123;            //代替原始实例工厂中创建对象的方法            public UserDao getObject() throws Exception &#123;                return new UserDaoImpl();            &#125;                    public Class&lt;?&gt; getObjectType() &#123;                return UserDao.class;            &#125;                &#125;        * 配置            * &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot;/&gt;5. bean生命周期    * 生命周期：从创建到消亡的完整过程    * bean生命周期：bean从创建到销毁的整体过程    * bean生命周期控制：在bean创建后到销毁前做一些事情        1. 提供生命周期控制方法            * public class BookDaoImpl implements BookDao &#123;                /*                    public BookDaoImpl()&#123;                        System.out.println(&quot;book dao constructor is running ...&quot;);                    &#125;*/                                    public void save()&#123;                        System.out.println(&quot;book dao save ...&quot;);                    &#125;                                    //表示bean初始化对应的操作                    public void init()&#123;                        System.out.println(&quot;init ... &quot;);                    &#125;                                    //表示bean销毁前对应的操作                    public void destory()&#123;                        System.out.println(&quot;destory ...&quot;);                    &#125;                                &#125;            * 配置生命周期控制方法                &lt;bean id =&quot;bookDao&quot; name=&quot;dao dao2 abc&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;        2. 实现InitializingBean，DisposableBean方法            * public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;                //5. 删除业务层使用new的方式创建的dao对象                private BookDao bookDao;                public void save()&#123;                    System.out.println(&quot;book service save ...&quot;);                    bookDao.save();                &#125;                            //6. 提供对应的set方法                public void setBookDao(BookDao bookDao) &#123;                    System.out.println(&quot;set ...&quot;);                    this.bookDao = bookDao;                &#125;                            public void destroy() throws Exception &#123;                    System.out.println(&quot;service destory&quot;);                &#125;                            public void afterPropertiesSet() throws Exception &#123;                    System.out.println(&quot;service init&quot;);                &#125;                        &#125;6. bean销毁时机    * 容器关闭前触发bean的销毁    * 关闭容器方式：        * 手工关闭容器            * ClassPathXmlApplicationContext接口close()操作        * 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机            * ClassPathXmlApplicationContext接口registerShutdownHook()操作    public class AppForBook &#123;        public static void main(String[] args) &#123;            //3. 获取IoC接口            ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);            //4. 获取bean            BookDao bookDao = (BookDao) ctx.getBean(&quot;abc&quot;);            bookDao.save();            ctx.close();//比较暴力，只能放在最后            //ctx.registerShutdownHook();//可以放在任意位置        &#125;    &#125;7. 依赖注入方式    1. setter注入        1. 引用类型            * 在bean中定义引用类型属性并提供可访问的set方法                * public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;                    //5. 删除业务层使用new的方式创建的dao对象                    private BookDao bookDao;                                                    //6. 提供对应的set方法                    public void setBookDao(BookDao bookDao) &#123;                        System.out.println(&quot;set ...&quot;);                        this.bookDao = bookDao;                    &#125;                &#125;            * 配置中使用property标签ref属性注入引用类型对象                *     &lt;bean id =&quot;bookDao&quot; name=&quot;dao dao2 abc&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;                      &lt;bean id=&quot;bookService&quot; name=&quot;service service1 bookEbi&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;        2. 简单类型            * 在bean中定义引用类型属性并提供可访问的set方法                * public class BookDaoImpl implements BookDao &#123;                    private int connectionNum;                    private String databaseName;                                    public void setConnectionNum(int connectionNum) &#123;                        this.connectionNum = connectionNum;                    &#125;                                    public void setDatabaseName(String databaseName) &#123;                        this.databaseName = databaseName;                    &#125;                    public void save()&#123;                        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot;+ connectionNum);                    &#125;                &#125;            1. 配置中使用property标签value属性注入简单类型数据                *     &lt;bean id =&quot;bookDao&quot; name=&quot;dao dao2 abc&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;                        &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;                        &lt;property name=&quot;connectionNum&quot; value=&quot;100&quot;/&gt;                    &lt;/bean&gt;            2. 配置中使用constructor-arg标签value属性注入简单类型数据                * &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;                    &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;                    &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt;                 &lt;/bean&gt;            3. 配置中使用constructor-arg标签type属性注入简单类型数据                * &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;                    &lt;constructor-arg type=&quot;int&quot; value=&quot;10&quot;/&gt;                    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;/&gt;                &lt;/bean&gt;            4. 配置中使用constructor-arg标签index属性注入简单类型数据                * &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;                    &lt;constructor-arg index=&quot;1&quot; value=&quot;mysql&quot;/&gt;                    &lt;constructor-arg index=&quot;0&quot; value=&quot;10&quot;/&gt;                &lt;/bean&gt;    2. 依赖注入方式选择        1. 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现        2. 可选依赖使用setter注入进行，灵活性强        3. spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化。相对严谨        4. 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入        5. 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入        6. 自己开发的模块推荐使用setter注入8. 依赖自动装配    * 概念：IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配    * 自动装配方式        * 按类型（常用）        * 按名称        * 按构造方法        * 不启用自动装配    1. 配置中使用bean标签autowire属性设置自动装配的类型        *  &lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;           &lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;        * 细节：            * 自动装配用于引用类型依赖注入，不能对简单类型进行操作            * 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用。            * 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用。            * 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失败。</code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习</title>
      <link href="/2022/12/29/%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/29/%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="不积跬步无以至千里"><a href="#不积跬步无以至千里" class="headerlink" title="不积跬步无以至千里"></a>不积跬步无以至千里</h2><ol><li>百度中下载的图片默认为webp类型，将它改成其他类型后，无法上传图片</li></ol><ul><li>解决方法：引入第三方支持处理webp图片类型的类库即可解决。因为thumbnailator底层使用的JDK的javax.imageio类库处理图片,<br>  显然JDK原生处理图片的类库只支持绝大部常见的图片类型，需要引入第三方类库对JDK的javax.imageio进行功能的补充和扩展,引入后<br>   系统会自动感知对业务代码无侵入性。</li></ul><ol start="2"><li>图片上传使用参数：</li></ol><ul><li>MultipartFile[] multipartFiles</li></ul><ol start="3"><li><p>照片原始名称：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipartFile.getOriginalFilename();</span><br></pre></td></tr></table></figure></li><li><p>照片大小：</p></li></ol><ul><li>DataSizeUtil.format();</li></ul><ol start="5"><li>注解：@Value(“${spring.profiles.active}”)</li></ol><ul><li>通过service中成员变量的注解，获取yaml中的profile</li></ul><ol start="6"><li>注解：@Slf4j</li></ol><ul><li>用作日志输出，一般在每个类的开头加入该注解，加入该注解，可以直接引用log.info()打印日志。</li></ul><ol start="7"><li>IdWorker.getIdStr()：</li></ol><ul><li>获取雪花id，保证既能保证唯一也能有序</li></ul><ol start="8"><li>FileUtil.extName():</li></ol><ul><li>获取文件扩展名，扩展名不包含”.”</li></ul><ol start="9"><li>DataSizeUtil.format():</li></ol><ul><li>读取本地文件的大小，并转为可读性较好的字符串</li></ul><ol start="10"><li><p>注解：@SneakyThrows</p><ul><li>省略try-catch中的catch</li></ul></li><li><p>用流输出设置文件的后缀</p><ul><li><p>xls:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpServletResponse.setContentType(&quot;application/vnd.ms-excel&quot;);</span><br></pre></td></tr></table></figure></li><li><p>xlsx:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpServletResponse.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ObjectUtil.isNull()是被包含在ObjectUtil.isEmpty()中：</p><ul><li>ObjectUtil.isNull()只能判断null</li><li>ObjectUtil.isEmpty()可以用于判断null和空，用于数组，对象等</li></ul></li><li><p>DateTimeFormatter将日期变换形式，定义时间格式</p><ul><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String转换为LocalDateTime，用LocalDate.parse()</p><ul><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">photoShareActivityManage.setStartTime(LocalDate.parse(addActivityBO.getStartTime(), dateTimeFormatter));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在有多租户情况下，TenantContextHolder.getTenantId()切换用户操作同一个多线程接口</p></li><li><p>注解@Cacheable：</p><ul><li><p>主要用于”查询”功能</p></li><li><p>有9个属性，其中value&#x2F;cacheNames属性，用来指定缓存组件的名称，即将方法的返回结果放在哪个缓存中，属性定义为数组，可以指定多个缓存；<br>key属性，用来指定缓存数据所使用的key，默认使用的是方法调用传过来的参数作为key。最终缓存中存储的内容格式为Entry&lt;key, value&gt;形式。</p></li><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value = &#123;&quot;TENANT_ACCESS_TOKEN&quot;&#125;, key = &quot;#tenantId&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用stream().forEach();来得到List封装里面的值，比for循环好用，for循环会出现一会好一会坏的情况</p><ul><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schemeItemAddBO.getSalaryItemsId().stream().forEach(salaryItemsId -&gt; &#123;</span><br><span class="line">   // 查询是否已选择薪酬项目</span><br><span class="line">   List&lt;HrSalaryCompensationSchemeSubSelected&gt; selectedList = hrSalaryCompensationSchemeSubSelectedMapper</span><br><span class="line">         .selectList(Wrappers.&lt;HrSalaryCompensationSchemeSubSelected&gt;lambdaQuery()</span><br><span class="line">               .eq(HrSalaryCompensationSchemeSubSelected::getSalaryCompensationSchemeId,</span><br><span class="line">                     schemeItemAddBO.getSchemeId())</span><br><span class="line">               .eq(HrSalaryCompensationSchemeSubSelected::getSalaryItemsId, salaryItemsId));</span><br><span class="line">   // 该方案存在已选择的薪酬项目</span><br><span class="line">   if (!selectedList.isEmpty()) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Optional.ofNullable()方法，避免空指针，且更为安全</p><ul><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(对象)</span><br><span class="line">.orElseThrow(() -&gt; new BizException(&quot;异常错误&quot;));//抛出异常</span><br><span class="line">原先：</span><br><span class="line">if (ObjectUtil.isNull(对象))</span><br><span class="line">    &#123;</span><br><span class="line">        throw new BizException(&quot;不存在&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>crm端口停止运行（或者直接电脑重启）：<br>7. netstat -aon|findstr “port值”<br>8. taskkill &#x2F;T &#x2F;F &#x2F;PID port值 ：停止正在运行的端口</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2022/12/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hello, 我是王丽敏，今天开始我要写我的第一篇博客了。</p><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><pre><code>1. Maven是什么    * Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）    * POM（Project Object Model）：项目对象模型2. Maven的作用    * 项目构建：提供标准的、跨平台的自动化项目构建方式    * 依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题    * 统一开发结构：提供标准的、统一的项目结构3. Maven基础概念    1. 仓库        1. 仓库：用于存储资源，包含各种jar包        2. 仓库分类：            1. 本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源            2. 远程仓库：非本机电脑上的仓库，为本地仓库提供资源                * 中央仓库：Maven团队维护，存储所有资源的仓库                * 私服：部门/公司范围内存储资源的仓库，从中央仓库获取资源        3. 私服的作用：            * 保存具有版权的资源，包含购买或自主研发的jar                * 中央仓库中的jar都是开源的，不能存储具有版权的资源            * 一定范围内共享资源，仅对内部开放，不对外共享    2. 坐标        1. 概念：Maven中的坐标用于描述仓库中资源的位置        2. Maven坐标主要组成            * groupId：定义当前Maven项目隶属组织名称                * 注意：通常是域名反写                * 例如：org.mybatis            * artifactId:定义当前Maven项目名称                * 通常是模块名称                * 例如：CRM,SMS            * version:定义当前项目版本号            * packaging:定义该项目的打包方式        3. Maven坐标的作用            使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</code></pre><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><pre><code>1. 依赖配置    * 概念：依赖指当前项目运行所需的jar，一个项目可以设置多个依赖    * 格式：          &lt;!--  设置当前项目所依赖的所有jar--&gt;          &lt;dependencies&gt;            &lt;!--具体依赖--&gt;            &lt;dependency&gt;              &lt;!--依赖所属群组id --&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;!-- 以来所属项目id--&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;!--依赖版本号--&gt;              &lt;version&gt;4.12&lt;/version&gt;            &lt;/dependency&gt;          &lt;/dependencies&gt;2. 依赖传递    1. 依赖具有传递性        * 直接依赖：在当前项目中通过依赖配置建立的依赖关系        * 间接依赖：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源        * 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的    2. 依赖传递冲突问题        * 路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高        * 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后        * 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的3. 可选依赖    * 概念：可选依赖指对外隐藏当前所依赖的资源--不透明。    * 示例：           &lt;dependency&gt;              &lt;groupId&gt;junit&lt;/groupId&gt;              &lt;artifactId&gt;junit&lt;/artifactId&gt;              &lt;version&gt;4.11&lt;/version&gt;              &lt;optional&gt;true&lt;/optional&gt;            &lt;/dependency&gt;4. 排除依赖    * 概念：排除依赖指主动断开依赖的资源，被排除的资源无需指定版本--不需要    * 示例：        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;                    &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;5. 依赖范围    * 概念：依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围    * 作用范围：        * 主程序范围有效（main文件夹范围内）        * 测试程序范围有效（test文件夹范围内）        * 是否参与打包（package指令范围内）6. 依赖范围的传递性    * 概念：带有依赖范围的资源在进行传递时，作用范围将受到影响</code></pre><p>|         | compile | test  |provided  |runtime  |  &lt;–直接依赖<br>| ——–|:——-:| —–:|———:|——–:|<br>| compile | compile | test  |          |runtime  |<br>| test    |         |       |          |         |<br>| provided|         |       |          |         |<br>| runtime | runtime |  test |          | runtime |<br> ↑  间接依赖 </p><h2 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h2><pre><code>1. 项目构建生命周期    * Maven对项目构建的生命周期分为3套        * clean:清理工作        * defaul:核心工作，例如编译，测试，打包，部署等        * site:产生报告，发布地点等2. 插件        * 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能        * 默认maven在各个生命周期上绑定有预设的功能        * 通过插件可以自定义其他功能</code></pre><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个00后小白程序员，平时我可能比较二，在各个平台上可以找到我，比如：</p><ul><li>哔哩哔哩：<a href="https://www.bilibili.com/?spm_id_from=333.999.b_696e7465726e6174696f6e616c486561646572.1">https://www.bilibili.com/?spm_id_from=333.999.b_696e7465726e6174696f6e616c486561646572.1</a></li></ul><p>我喜欢聊天，但是现实中有些腼腆，属于内热外冷型，有时候会自说自话发表一些很幼稚的鸡汤和牢骚，如果在评论区看到我，可以跟我打个招呼哦！</p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
